/// Represents a problem result for adaptive learning
class ProblemResult {
  final String problemId;
  final int level;
  final bool correct;
  final double timeTaken; // in seconds
  final bool bondCorrect;
  final DateTime timestamp;
  final String problemText;
  final String childId;

  const ProblemResult({
    required this.problemId,
    required this.level,
    required this.correct,
    required this.timeTaken,
    required this.bondCorrect,
    required this.timestamp,
    required this.problemText,
    required this.childId,
  });

  Map<String, dynamic> toJson() {
    return {
      'problemId': problemId,
      'level': level,
      'correct': correct,
      'timeTaken': timeTaken,
      'bondCorrect': bondCorrect,
      'timestamp': timestamp.toIso8601String(),
      'problemText': problemText,
      'childId': childId,
    };
  }

  factory ProblemResult.fromJson(Map<String, dynamic> json) {
    return ProblemResult(
      problemId: json['problemId'] as String,
      level: json['level'] as int,
      correct: json['correct'] as bool,
      timeTaken: (json['timeTaken'] as num).toDouble(),
      bondCorrect: json['bondCorrect'] as bool,
      timestamp: DateTime.parse(json['timestamp'] as String),
      problemText: json['problemText'] as String,
      childId: json['childId'] as String,
    );
  }
}

/// Represents a challenge problem generated by the adaptive engine
class AdaptiveChallenge {
  final String problemId;
  final String problemText;
  final int level;
  final String bondSteps;
  final int operand1;
  final int operand2;
  final String operator;
  final int correctAnswer;
  final bool isReviewProblem;
  final String? motivationalMessage;

  const AdaptiveChallenge({
    required this.problemId,
    required this.problemText,
    required this.level,
    required this.bondSteps,
    required this.operand1,
    required this.operand2,
    required this.operator,
    required this.correctAnswer,
    this.isReviewProblem = false,
    this.motivationalMessage,
  });

  Map<String, dynamic> toJson() {
    return {
      'problemId': problemId,
      'problemText': problemText,
      'level': level,
      'bondSteps': bondSteps,
      'operand1': operand1,
      'operand2': operand2,
      'operator': operator,
      'correctAnswer': correctAnswer,
      'isReviewProblem': isReviewProblem,
      'motivationalMessage': motivationalMessage,
    };
  }

  factory AdaptiveChallenge.fromJson(Map<String, dynamic> json) {
    return AdaptiveChallenge(
      problemId: json['problemId'] as String,
      problemText: json['problemText'] as String,
      level: json['level'] as int,
      bondSteps: json['bondSteps'] as String,
      operand1: json['operand1'] as int,
      operand2: json['operand2'] as int,
      operator: json['operator'] as String,
      correctAnswer: json['correctAnswer'] as int,
      isReviewProblem: json['isReviewProblem'] as bool? ?? false,
      motivationalMessage: json['motivationalMessage'] as String?,
    );
  }
}

/// Performance metrics for a child
class PerformanceMetrics {
  final double accuracy;
  final double averageTime;
  final int consecutiveIncorrect;
  final List<int> recentLevels;
  final Map<int, double> levelAccuracy;

  const PerformanceMetrics({
    required this.accuracy,
    required this.averageTime,
    required this.consecutiveIncorrect,
    required this.recentLevels,
    required this.levelAccuracy,
  });
}

/// Challenge level definitions
enum ChallengeLevel {
  level1('Single-digit addition (make-a-ten)', 1, 1, 9, 'addition'),
  level2('2-digit + 1-digit addition/subtraction', 2, 10, 99, 'mixed'),
  level3('2-digit + 2-digit with regrouping', 3, 10, 99, 'mixed'),
  level4('Up to 3-digit problems (â‰¤1000)', 4, 100, 999, 'mixed');

  const ChallengeLevel(this.description, this.level, this.minValue, this.maxValue, this.operation);

  final String description;
  final int level;
  final int minValue;
  final int maxValue;
  final String operation; // 'addition', 'subtraction', 'mixed'

  static ChallengeLevel getByLevel(int level) {
    return ChallengeLevel.values.firstWhere(
      (l) => l.level == level,
      orElse: () => ChallengeLevel.level1,
    );
  }
}
